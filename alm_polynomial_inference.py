from functools import partial

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

import nregions_inference as NRI
import src.sky_models as SM
import src.forward_model as FM
from anstey.generate import T_CMB


def _alm_forward_model(nuarr, *c, a00_offset=False):
    """
    Calculate the alm polynomial given a vector of components c = (A/1000, alpha, *zetas)
    Note the rescaling on the A term.
    """
    A, alpha = c[:2]
    zetas    = c[2:]
    exponent = [zetas[i]*np.log(nuarr/60)**(i+2) for i in range(len(zetas))]
    alm_term = (A*1e3)*(nuarr/60)**(-alpha) * np.exp(np.sum(exponent, 0))
    if a00_offset:
        alm_term += np.sqrt(4*np.pi)*T_CMB
    return alm_term

def _regress_powerlaw(nuarr, alm, Npoly=2, a00_offset=False):
    """
    Assuming that alm = A(nu/60)^alpha exp(zeta_0 log(nuarr/60)^2 + zeta_1 log(nuarr/60)^3 + ...)
    find the vector of values c=(A, alpha, zeta_0, ...) up to Npoly total terms.

    This can deal with negative alm functions.
    """
    assert Npoly >= 2
    
    # Guess at the initial parameters
    if np.all(alm>0):
        p0 = [10, 2.5] + [0.001]*(Npoly-2)
    elif np.all(alm<0):
        p0 = [-10, 2.5] + [0.001]*(Npoly-2)
    else:
        return 0
    f = partial(_alm_forward_model, a00_offset=a00_offset)
    fit, cov = curve_fit(f, nuarr, alm, p0=p0)

    return fit, cov

def _fit_alms(nuarr, alm_list, Npoly=4):
    """
    Fit a list of alms from a00 upwards.
    """
    fitlist = []
    for i, alm in enumerate(alm_list):
        try:
            if i==0:
                a00_offset=True
            else:
                a00_offset=False
            fit, _ = _regress_powerlaw(nuarr, alm, Npoly=Npoly, a00_offset=a00_offset)
        except:
            print(f"Error: cannot fit {i} as it has a zero-crossing, skipping it for now.")
        fitlist.append(fit)
    return np.array(fitlist)


def compare_polyn_reconstructions(lmax, lmod, Npoly):
    """
    Compare data generated by observing a fiducial lmax model with data generated by 
    observing an lmod model, who's alm parameters are polynomial best-fits of
    the alms of the lmax model. The polynomial order to fit up to is controlled
    by Npoly.
    """
    # Generate data.
    nside = 32
    times = np.linspace(0, 6, 3)
    noise = 0.0
    dnoisy, noise_covar, mat_A, mat_Y, params = NRI.fiducial_obs(
        uniform_noise=True,
        unoise_K = noise,
        times = times,
        Ntau = len(times),
        lmax = lmax,
        nside = nside
    )
    derr = np.sqrt(np.diag(noise_covar.matrix))
    plt.plot(dnoisy.vector, '.', label='mock data')
    plt.xlabel("bin")
    plt.ylabel("Temp [K]")


    # Fit the first lmod alms of the fiducial model.
    nuarr = NRI.nuarr
    a = SM.foreground_gsma_alm_nsidelo(nu=nuarr, lmax=lmod, nside=nside, use_mat_Y=True)
    a_sep = np.array(np.split(a, len(nuarr)))

    fitlist=_fit_alms(nuarr=nuarr, alm_list=a_sep.T, Npoly=Npoly)

    # Evaluating the model at the fiducial parameter set.
    mod = FM.genopt_alm_pl_forward_model(nuarr, observation_mat=mat_A, Npoly=Npoly, lmax=lmod)
    dmod = mod(fitlist.flatten())
    plt.plot(dmod, '.', label='fiducial model')
    plt.legend()
    plt.show()

    plt.errorbar(list(range(len(dnoisy.vector))),dnoisy.vector-dmod, yerr=derr,fmt='.')
    plt.xlabel("bin")
    plt.ylabel("Temp residuals [K]")
    plt.show()
